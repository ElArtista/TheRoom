\section{Architecture}
Before moving on to the various algorithms used to improve the engine's visual output, a few
words need to be said about its architecture.

At its core, the engine operates on a loop, \textit{Updating} at least once per 5 frames 
and \textit{Rendering} in the idle time between updates. The loop ends when it gets an exit
signal. Note that the rendering is interpolated to improve quality and make it feel more natural.
From an extremely distant point of view, that is all there is to it. Naturally there are various
utilities that help with those two tasks and they will be briefly explained in the following
sections.

\subsection{Window}
Another decoupled yet important part of the engine is the Window. To create an OpenGL context
GLFW is used. However, all the window creating logic is separated from everything else, hence it
is easy to implement window utilities (e.g.\ change title, subscribe to events) or even replace
GLFW if there is a need to do that.

\subsection{State Management}
State Management

\subsection{Assets}
One of the governing aspects of a game engine is the Assets loading and management. For the
purpose of promoting modularization and eliminating code duplication a convention was made.

\noindent Assets are divided on two categories (or even better, two states):

\begin{itemize}
\item Assets that are loaded from disk and stored to RAM
\item Assets that are loaded to the GPU
\end{itemize}

\noindent Of course, an asset needs to be loaded from disk first, in order to load it to the GPU\@.

Basically, assets are discriminated based on their state. When one starts thinking of them that
way, it is easy to notice that many modules do not actually require the asset itself. For
instance, the Rendering module only expects an identifier for the loaded asset; it has no use
for the actual loaded data. Using that convention has proven a wise decision since it speeded
up debugging and developing.

Throughout the code there are many independent asset loaders, for images, models, scenefiles etc..
and \textit{Asset Stores}, which get as input the loaded data, upload it to the GPU and save an
identifier to access them. All asset stores are maps with strings as key. That string represents
a unique way to reference an asset, like a name or a UUID\@.

\subsection{Shader}
One of the greatest and most annoying problems a graphics developer encounters is the hassle of
having to restart the whole program for just a simple alteration to a shader. To address that
problem the following convention was made:

\noindent Shaders are divided to two categories:

\begin{itemize}
\item Static shaders, embedded in source code
\item Normal shaders, in their own glsl files
\end{itemize}

\noindent Static shaders are needed for independent features that are not likely to change often,
just like the shaders for Shadow Maps or Cubemaps. Normal shaders, on the other hand, are those
that contain all lighting equations (among other thigns) and that usually means that they are a
lot more likely to change.\\
There were two features developed for that reason.

\subsubsection{Shader Modularization}
As the engine grows larger the features usually get more complex. GLSL is not an exception to that
rule. The engine's GLSL is enchanced with a preprocessing mechanism that promotes code reusability
and modularity. For the time being, the only preprocessor directives implemented are those of
\textit{\#include} and \textit{\#module} which are respectively used to include a module to the
current one and declare a file as a separate module. Note that multiple includes are ignored by
default\footnote{Just like using include guards in C/C++}.

\subsubsection{Shader Reloading}
As stated earlier, many shaders needs to be reloaded many times during development. Restarting
the program meant reloading all the assets which means waiting time. Shader Reloading feature
comes to the rescue as it eliminates the need for program restarting for mere changes in shaders.
They can be reloaded on the fly, and if there is an error, a message box appears without stopping
the program.

\subsection{Embedded Shell}
Embedded Shell
